{"version":3,"sources":["../node_modules/draftjs-to-html/lib/draftjs-to-html.js","components/Blog/Post/index.js","containers/Blog/Post/index.js"],"names":["module","exports","forEach","obj","callback","key","hasOwnProperty","call","blockTypesMapping","unstyled","header-one","header-two","header-three","header-four","header-five","header-six","unordered-list-item","ordered-list-item","blockquote","code","getBlockTag","type","getBlockStyle","data","styles","value","isAtomicEntityBlock","block","entityRanges","length","str","text","undefined","trim","getStylesAtOffset","inlineStyles","offset","COLOR","BGCOLOR","FONTSIZE","FONTFAMILY","UNDERLINE","ITALIC","BOLD","STRIKETHROUGH","CODE","SUBSCRIPT","SUPERSCRIPT","sameStyleAsPrevious","index","sameStyled","style","getEntityMarkup","entityMap","entityKey","customEntityTransform","entity","html","url","targetOption","src","alt","alignment","height","width","getInlineStyleSections","start","end","styleSections","inlineStyleRanges","Array","range","i","indexOf","substring","getStyleArrayForBlock","section","push","getInlineStyleSectionMarkup","styleSection","styleTagSections","styleSectionText","stylePropertySection","content","chars","map","ch","join","getSectionText","addInlineStyleMarkup","getStyleTagSectionMarkup","styleString","test","addStylePropertyMarkup","getBlockInnerMarkup","hashtagConfig","blockMarkup","sections","lastOffset","sectionRanges","concat","blockText","counter","startIndex","trigger","separator","substr","endIndex","hashtag","getHashtagRanges","sort","s1","s2","r","getSections","sectionText","entityInlineMarkup","getSectionMarkup","replacedText","replace","trimLeadingZeros","trimTrailingZeros","getListMarkup","listBlocks","directional","listHtml","nestedListBlock","previousBlock","nestedBlock","depth","blockStyle","editorContent","blocks","blockType","blockHtml","blockTag","getBlockMarkup","factory","Post","componentDidMount","_this$props","_this","props","getPost","params","match","id","selectedPost","this","draftToHtml","JSON","parse","react_default","a","createElement","className","row","col","span","card","title","headStyle","fontSize","spin","spinning","size","dangerouslySetInnerHTML","__html","Component","connect","_ref","blog","loading"],"mappings":"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","file":"static/js/9.5e95c187.chunk.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.draftjsToHtml = factory();\n})(this, function () {\n  'use strict';\n  /**\n  * Utility function to execute callback for eack key->value pair.\n  */\n\n  function forEach(obj, callback) {\n    if (obj) {\n      for (var key in obj) {\n        // eslint-disable-line no-restricted-syntax\n        if ({}.hasOwnProperty.call(obj, key)) {\n          callback(key, obj[key]);\n        }\n      }\n    }\n  }\n  /**\n  * The function returns true if the string passed to it has no content.\n  */\n\n\n  function isEmptyString(str) {\n    if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * Mapping block-type to corresponding html tag.\n  */\n\n\n  var blockTypesMapping = {\n    unstyled: 'p',\n    'header-one': 'h1',\n    'header-two': 'h2',\n    'header-three': 'h3',\n    'header-four': 'h4',\n    'header-five': 'h5',\n    'header-six': 'h6',\n    'unordered-list-item': 'ul',\n    'ordered-list-item': 'ol',\n    blockquote: 'blockquote',\n    code: 'pre'\n  };\n  /**\n  * Function will return HTML tag for a block.\n  */\n\n  function getBlockTag(type) {\n    return type && blockTypesMapping[type];\n  }\n  /**\n  * Function will return style string for a block.\n  */\n\n\n  function getBlockStyle(data) {\n    var styles = '';\n    forEach(data, function (key, value) {\n      if (value) {\n        styles += key + ':' + value + ';';\n      }\n    });\n    return styles;\n  }\n  /**\n  * The function returns an array of hashtag-sections in blocks.\n  * These will be areas in block which have hashtags applicable to them.\n  */\n\n\n  function getHashtagRanges(blockText, hashtagConfig) {\n    var sections = [];\n\n    if (hashtagConfig) {\n      var counter = 0;\n      var startIndex = 0;\n      var text = blockText;\n      var trigger = hashtagConfig.trigger || '#';\n      var separator = hashtagConfig.separator || ' ';\n\n      for (; text.length > 0 && startIndex >= 0;) {\n        if (text[0] === trigger) {\n          startIndex = 0;\n          counter = 0;\n          text = text.substr(trigger.length);\n        } else {\n          startIndex = text.indexOf(separator + trigger);\n\n          if (startIndex >= 0) {\n            text = text.substr(startIndex + (separator + trigger).length);\n            counter += startIndex + separator.length;\n          }\n        }\n\n        if (startIndex >= 0) {\n          var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n          var hashtag = text.substr(0, endIndex);\n\n          if (hashtag && hashtag.length > 0) {\n            sections.push({\n              offset: counter,\n              length: hashtag.length + trigger.length,\n              type: 'HASHTAG'\n            });\n          }\n\n          counter += trigger.length;\n        }\n      }\n    }\n\n    return sections;\n  }\n  /**\n  * The function returns an array of entity-sections in blocks.\n  * These will be areas in block which have same entity or no entity applicable to them.\n  */\n\n\n  function getSections(block, hashtagConfig) {\n    var sections = [];\n    var lastOffset = 0;\n    var sectionRanges = block.entityRanges.map(function (range) {\n      var offset = range.offset,\n          length = range.length,\n          key = range.key;\n      return {\n        offset: offset,\n        length: length,\n        key: key,\n        type: 'ENTITY'\n      };\n    });\n    sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n    sectionRanges = sectionRanges.sort(function (s1, s2) {\n      return s1.offset - s2.offset;\n    });\n    sectionRanges.forEach(function (r) {\n      if (r.offset > lastOffset) {\n        sections.push({\n          start: lastOffset,\n          end: r.offset\n        });\n      }\n\n      sections.push({\n        start: r.offset,\n        end: r.offset + r.length,\n        entityKey: r.key,\n        type: r.type\n      });\n      lastOffset = r.offset + r.length;\n    });\n\n    if (lastOffset < block.text.length) {\n      sections.push({\n        start: lastOffset,\n        end: block.text.length\n      });\n    }\n\n    return sections;\n  }\n  /**\n  * Function to check if the block is an atomic entity block.\n  */\n\n\n  function isAtomicEntityBlock(block) {\n    if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * The function will return array of inline styles applicable to the block.\n  */\n\n\n  function getStyleArrayForBlock(block) {\n    var text = block.text,\n        inlineStyleRanges = block.inlineStyleRanges;\n    var inlineStyles = {\n      BOLD: new Array(text.length),\n      ITALIC: new Array(text.length),\n      UNDERLINE: new Array(text.length),\n      STRIKETHROUGH: new Array(text.length),\n      CODE: new Array(text.length),\n      SUPERSCRIPT: new Array(text.length),\n      SUBSCRIPT: new Array(text.length),\n      COLOR: new Array(text.length),\n      BGCOLOR: new Array(text.length),\n      FONTSIZE: new Array(text.length),\n      FONTFAMILY: new Array(text.length),\n      length: text.length\n    };\n\n    if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n      inlineStyleRanges.forEach(function (range) {\n        var offset = range.offset;\n        var length = offset + range.length;\n\n        for (var i = offset; i < length; i += 1) {\n          if (range.style.indexOf('color-') === 0) {\n            inlineStyles.COLOR[i] = range.style.substring(6);\n          } else if (range.style.indexOf('bgcolor-') === 0) {\n            inlineStyles.BGCOLOR[i] = range.style.substring(8);\n          } else if (range.style.indexOf('fontsize-') === 0) {\n            inlineStyles.FONTSIZE[i] = range.style.substring(9);\n          } else if (range.style.indexOf('fontfamily-') === 0) {\n            inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n          } else if (inlineStyles[range.style]) {\n            inlineStyles[range.style][i] = true;\n          }\n        }\n      });\n    }\n\n    return inlineStyles;\n  }\n  /**\n  * The function will return inline style applicable at some offset within a block.\n  */\n\n\n  function getStylesAtOffset(inlineStyles, offset) {\n    var styles = {};\n\n    if (inlineStyles.COLOR[offset]) {\n      styles.COLOR = inlineStyles.COLOR[offset];\n    }\n\n    if (inlineStyles.BGCOLOR[offset]) {\n      styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n    }\n\n    if (inlineStyles.FONTSIZE[offset]) {\n      styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n    }\n\n    if (inlineStyles.FONTFAMILY[offset]) {\n      styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n    }\n\n    if (inlineStyles.UNDERLINE[offset]) {\n      styles.UNDERLINE = true;\n    }\n\n    if (inlineStyles.ITALIC[offset]) {\n      styles.ITALIC = true;\n    }\n\n    if (inlineStyles.BOLD[offset]) {\n      styles.BOLD = true;\n    }\n\n    if (inlineStyles.STRIKETHROUGH[offset]) {\n      styles.STRIKETHROUGH = true;\n    }\n\n    if (inlineStyles.CODE[offset]) {\n      styles.CODE = true;\n    }\n\n    if (inlineStyles.SUBSCRIPT[offset]) {\n      styles.SUBSCRIPT = true;\n    }\n\n    if (inlineStyles.SUPERSCRIPT[offset]) {\n      styles.SUPERSCRIPT = true;\n    }\n\n    return styles;\n  }\n  /**\n  * Function returns true for a set of styles if the value of these styles at an offset\n  * are same as that on the previous offset.\n  */\n\n\n  function sameStyleAsPrevious(inlineStyles, styles, index) {\n    var sameStyled = true;\n\n    if (index > 0 && index < inlineStyles.length) {\n      styles.forEach(function (style) {\n        sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n      });\n    } else {\n      sameStyled = false;\n    }\n\n    return sameStyled;\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n\n  function addInlineStyleMarkup(style, content) {\n    if (style === 'BOLD') {\n      return '<strong>' + content + '</strong>';\n    } else if (style === 'ITALIC') {\n      return '<em>' + content + '</em>';\n    } else if (style === 'UNDERLINE') {\n      return '<ins>' + content + '</ins>';\n    } else if (style === 'STRIKETHROUGH') {\n      return '<del>' + content + '</del>';\n    } else if (style === 'CODE') {\n      return '<code>' + content + '</code>';\n    } else if (style === 'SUPERSCRIPT') {\n      return '<sup>' + content + '</sup>';\n    } else if (style === 'SUBSCRIPT') {\n      return '<sub>' + content + '</sub>';\n    }\n\n    return content;\n  }\n  /**\n  * The function returns text for given section of block after doing required character replacements.\n  */\n\n\n  function getSectionText(text) {\n    if (text && text.length > 0) {\n      var chars = text.map(function (ch) {\n        switch (ch) {\n          case '\\n':\n            return '<br>';\n\n          case '&':\n            return '&amp;';\n\n          case '<':\n            return '&lt;';\n\n          case '>':\n            return '&gt;';\n\n          default:\n            return ch;\n        }\n      });\n      return chars.join('');\n    }\n\n    return '';\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n\n  function addStylePropertyMarkup(styles, text) {\n    if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n      var styleString = 'style=\"';\n\n      if (styles.COLOR) {\n        styleString += 'color: ' + styles.COLOR + ';';\n      }\n\n      if (styles.BGCOLOR) {\n        styleString += 'background-color: ' + styles.BGCOLOR + ';';\n      }\n\n      if (styles.FONTSIZE) {\n        styleString += 'font-size: ' + styles.FONTSIZE + (/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '') + ';';\n      }\n\n      if (styles.FONTFAMILY) {\n        styleString += 'font-family: ' + styles.FONTFAMILY + ';';\n      }\n\n      styleString += '\"';\n      return '<span ' + styleString + '>' + text + '</span>';\n    }\n\n    return text;\n  }\n  /**\n  * Function will return markup for Entity.\n  */\n\n\n  function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n    var entity = entityMap[entityKey];\n\n    if (typeof customEntityTransform === 'function') {\n      var html = customEntityTransform(entity, text);\n\n      if (html) {\n        return html;\n      }\n    }\n\n    if (entity.type === 'MENTION') {\n      return '<a href=\"' + entity.data.url + '\" class=\"wysiwyg-mention\" data-mention data-value=\"' + entity.data.value + '\">' + text + '</a>';\n    }\n\n    if (entity.type === 'LINK') {\n      var targetOption = entity.data.targetOption || '_self';\n      return '<a href=\"' + entity.data.url + '\" target=\"' + targetOption + '\">' + text + '</a>';\n    }\n\n    if (entity.type === 'IMAGE') {\n      return '<img src=\"' + entity.data.src + '\" alt=\"' + entity.data.alt + '\" style=\"float:' + (entity.data.alignment || 'none') + ';height: ' + entity.data.height + ';width: ' + entity.data.width + '\"/>';\n    }\n\n    if (entity.type === 'EMBEDDED_LINK') {\n      return '<iframe width=\"' + entity.data.width + '\" height=\"' + entity.data.height + '\" src=\"' + entity.data.src + '\" frameBorder=\"0\"></iframe>';\n    }\n\n    return text;\n  }\n  /**\n  * For a given section in a block the function will return a further list of sections,\n  * with similar inline styles applicable to them.\n  */\n\n\n  function getInlineStyleSections(block, styles, start, end) {\n    var styleSections = [];\n    var text = block.text;\n\n    if (text.length > 0) {\n      var inlineStyles = getStyleArrayForBlock(block);\n      var section = void 0;\n\n      for (var i = start; i < end; i += 1) {\n        if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n          section.text.push(text[i]);\n          section.end = i + 1;\n        } else {\n          section = {\n            styles: getStylesAtOffset(inlineStyles, i),\n            text: [text[i]],\n            start: i,\n            end: i + 1\n          };\n          styleSections.push(section);\n        }\n      }\n    }\n\n    return styleSections;\n  }\n  /**\n  * Replace leading blank spaces by &nbsp;\n  */\n\n\n  function trimLeadingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = 0; i < replacedText.length; i += 1) {\n        if (sectionText[i] === ' ') {\n          replacedText = replacedText.replace(' ', '&nbsp;');\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * Replace trailing blank spaces by &nbsp;\n  */\n\n\n  function trimTrailingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n        if (replacedText[i] === ' ') {\n          replacedText = replacedText.substring(0, i) + '&nbsp;' + replacedText.substring(i + 1);\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n  */\n\n\n  function getStyleTagSectionMarkup(styleSection) {\n    var styles = styleSection.styles,\n        text = styleSection.text;\n    var content = getSectionText(text);\n    forEach(styles, function (style, value) {\n      content = addInlineStyleMarkup(style, content, value);\n    });\n    return content;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  like color, background-color, font-size are applicable.\n  */\n\n\n  function getInlineStyleSectionMarkup(block, styleSection) {\n    var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n    var styleSectionText = '';\n    styleTagSections.forEach(function (stylePropertySection) {\n      styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n    });\n    styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n    return styleSectionText;\n  }\n  /*\n  * The method returns markup for an entity section.\n  * An entity section is a continuous section in a block\n  * to which same entity or no entity is applicable.\n  */\n\n\n  function getSectionMarkup(block, entityMap, section, customEntityTransform) {\n    var entityInlineMarkup = [];\n    var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n    inlineStyleSections.forEach(function (styleSection) {\n      entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n    });\n    var sectionText = entityInlineMarkup.join('');\n\n    if (section.type === 'ENTITY') {\n      if (section.entityKey !== undefined && section.entityKey !== null) {\n        sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n      }\n    } else if (section.type === 'HASHTAG') {\n      sectionText = '<a href=\"' + sectionText + '\" class=\"wysiwyg-hashtag\">' + sectionText + '</a>';\n    }\n\n    return sectionText;\n  }\n  /**\n  * Function will return the markup for block preserving the inline styles and\n  * special characters like newlines or blank spaces.\n  */\n\n\n  function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n    var blockMarkup = [];\n    var sections = getSections(block, hashtagConfig);\n    sections.forEach(function (section, index) {\n      var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n\n      if (index === 0) {\n        sectionText = trimLeadingZeros(sectionText);\n      }\n\n      if (index === sections.length - 1) {\n        sectionText = trimTrailingZeros(sectionText);\n      }\n\n      blockMarkup.push(sectionText);\n    });\n    return blockMarkup.join('');\n  }\n  /**\n  * Function will return html for the block.\n  */\n\n\n  function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var blockHtml = [];\n\n    if (isAtomicEntityBlock(block)) {\n      blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n    } else {\n      var blockTag = getBlockTag(block.type);\n\n      if (blockTag) {\n        blockHtml.push('<' + blockTag);\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          blockHtml.push(' style=\"' + blockStyle + '\"');\n        }\n\n        if (directional) {\n          blockHtml.push(' dir = \"auto\"');\n        }\n\n        blockHtml.push('>');\n        blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        blockHtml.push('</' + blockTag + '>');\n      }\n    }\n\n    blockHtml.push('\\n');\n    return blockHtml.join('');\n  }\n  /**\n  * Function to check if a block is of type list.\n  */\n\n\n  function isList(blockType) {\n    return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n  }\n  /**\n  * Function will return html markup for a list block.\n  */\n\n\n  function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var listHtml = [];\n    var nestedListBlock = [];\n    var previousBlock = void 0;\n    listBlocks.forEach(function (block) {\n      var nestedBlock = false;\n\n      if (!previousBlock) {\n        listHtml.push('<' + getBlockTag(block.type) + '>\\n');\n      } else if (previousBlock.type !== block.type) {\n        listHtml.push('</' + getBlockTag(previousBlock.type) + '>\\n');\n        listHtml.push('<' + getBlockTag(block.type) + '>\\n');\n      } else if (previousBlock.depth === block.depth) {\n        if (nestedListBlock && nestedListBlock.length > 0) {\n          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n          nestedListBlock = [];\n        }\n      } else {\n        nestedBlock = true;\n        nestedListBlock.push(block);\n      }\n\n      if (!nestedBlock) {\n        listHtml.push('<li');\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          listHtml.push(' style=\"' + blockStyle + '\"');\n        }\n\n        if (directional) {\n          listHtml.push(' dir = \"auto\"');\n        }\n\n        listHtml.push('>');\n        listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        listHtml.push('</li>\\n');\n        previousBlock = block;\n      }\n    });\n\n    if (nestedListBlock && nestedListBlock.length > 0) {\n      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n    }\n\n    listHtml.push('</' + getBlockTag(previousBlock.type) + '>\\n');\n    return listHtml.join('');\n  }\n  /**\n  * The function will generate html markup for given draftjs editorContent.\n  */\n\n\n  function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n    var html = [];\n\n    if (editorContent) {\n      var blocks = editorContent.blocks,\n          entityMap = editorContent.entityMap;\n\n      if (blocks && blocks.length > 0) {\n        var listBlocks = [];\n        blocks.forEach(function (block) {\n          if (isList(block.type)) {\n            listBlocks.push(block);\n          } else {\n            if (listBlocks.length > 0) {\n              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n\n              html.push(listHtml);\n              listBlocks = [];\n            }\n\n            var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n            html.push(blockHtml);\n          }\n        });\n\n        if (listBlocks.length > 0) {\n          var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n\n          html.push(listHtml);\n          listBlocks = [];\n        }\n      }\n    }\n\n    return html.join('');\n  }\n\n  return draftToHtml;\n});","import React, { Component } from 'react'\r\nimport {\r\n  Card, Spin, Row, Col\r\n} from 'antd'\r\nimport draftToHtml from 'draftjs-to-html'\r\nimport PropTypes from 'prop-types'\r\n\r\nclass Post extends Component {\r\n  componentDidMount = () => {\r\n    const { getPost, match } = this.props\r\n    const { params } = match\r\n    if (params.id) {\r\n      getPost(params.id)\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { selectedPost } = this.props\r\n    const content = selectedPost.content ? draftToHtml(JSON.parse(selectedPost.content)) : ''\r\n\r\n    return (\r\n      <div className=\"gx-main-content gx-pb-sm-4\">\r\n        <Row>\r\n          <Col span={24}>\r\n            <Card title={selectedPost.title} headStyle={{ fontSize: '40px' }}>\r\n              <Spin spinning={false} size=\"large\">\r\n                <div className=\"post\" dangerouslySetInnerHTML={{ __html: content }} />\r\n              </Spin>\r\n            </Card>\r\n          </Col>\r\n        </Row>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nPost.propTypes = {\r\n  getPost: PropTypes.func.isRequired,\r\n  match: PropTypes.shape().isRequired,\r\n  selectedPost: PropTypes.shape().isRequired\r\n}\r\n\r\nexport default Post\r\n","import { connect } from 'react-redux'\r\nimport { getPost } from 'appRedux/actions/Blog'\r\nimport Post from 'components/Blog/Post'\r\n\r\nconst mapStateToProps = ({ blog }) => {\r\n  const { selectedPost, loading } = blog\r\n  return { selectedPost, loading }\r\n}\r\n\r\nexport default connect(mapStateToProps, { getPost })(Post)\r\n"],"sourceRoot":""}